---
title: "Single Peptide Results Analysis - UPS Dataset"
author: "Caleb Easterly and Ray Sajulga"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```
**September 17, 2018**
## Introduction
Analysis adapted from Caleb Easterly's "Single Peptide Results Analysis" (https://github.com/caleb-easterly/single_peptide) for the UPS dataset.

---

Let's get the dynamic amounts for each UPS protein
```{r}
ups_ratios <- read.csv("UPS-Protein-Ratios.tsv", sep = "\t",
                header = TRUE, stringsAsFactors = FALSE) %>%
  select(ups2_amount = UPS2.Amount..fmol.,
         protein = UniProt.Accession.Number)
```

### Peptide Sampling
Let's randomly select 10 UPS peptides and 10 non-UPS peptides from the UPS1 dataset (replicate #3):

```{r}
library(dplyr)
library(stringr)
# Obtains peptide report
peptide_report <- read.csv("Data/UPS/UPS1/UPS1_03_[Peptide_Shaker_on_data_21__Peptide_Report].tabular",
         sep = "\t", comment.char="", header = TRUE, stringsAsFactors = FALSE) %>%
  select(proteins = Protein.s.,
         sequence = Sequence,
         counts = X.Validated.PSMs)

# Extracts the UPS peptide rows
ups_peptides <- filter(peptide_report, grepl("ups", proteins)) %>%
  mutate(protein = str_extract(proteins, "[A-Z][0-9]+")) %>%
  filter(protein %in% ups_ratios$protein)

# Randomly selects 20 peptides
set.seed(1003)
peptides <- ups_peptides[sample(nrow(ups_peptides), 20),]$sequence

# Concatenates the two categories and writes it out in a text file for analysis
write.table(peptides, "twenty_peptides.txt", 
            sep="\n", quote=FALSE, row.names=FALSE, col.names=FALSE)
peptides
```

### Unipept

#### Process
* Paste the tabular list of peptides into the Unipept ‘Metaproteomics Analysis’ web application (https://morty.ugent.be/mpa)  
* Parameters:
    - Equate I and L: FALSE
    - Filter duplicate peptides: FALSE
    - Advanced missed cleavage handling: TRUE
* Download results
* Annotate each peptide with only the GO terms that are present in 5% or more of the proteins (percentages are returned in GO term column)

```{r}
cov_pat <- "\ \\(.{2,4}\\)"
uni <- read.csv('results/unipept/UPS_03-Unipept-20pep-1003seed.csv',
                stringsAsFactors = FALSE) %>%
    select(peptide,
           uni_go_bp = GO..biological.process.,
           uni_go_mf = GO..molecular.function.,
           uni_go_cc = GO..cellular.component.) %>%
    filter(peptide %in% fivepep) %>%
    mutate(uni_go_bp = str_replace_all(string = uni_go_bp, pattern = cov_pat, replacement = ""),
           uni_go_mf = str_replace_all(string = uni_go_mf, pattern = cov_pat, replacement = ""),
           uni_go_cc = str_replace_all(string = uni_go_cc, pattern = cov_pat, replacement = ""))
```



### eggNOG mapper
* Use the Galaxy version of eggNOG mapper, on Galaxy-P
* Parameters:
    - Annotation type: DIAMOND
    - Scoring matrix and gap costs: PAM30, 9 and 1
    - Taxonomic Scope: Mammals
    - Orthologs: use all orthologs
    - Gene Ontology evidence: use non-electronic terms
    - Seed Orthology Search Options
        - Min e-value: 200000
        - Min bit score: 20
* Download and compare GO terms
  
```{r}
em <- read.delim("results/eggNOG/eggnog_mapper_20_sequences_results_seed-1003.tabular",
                 stringsAsFactors = FALSE,
                 header=FALSE) %>%
    select(peptide = V1, em_prot = V2, em_go = V6, em_gene = V5, em_descript = V13) %>%
    filter(peptide %in% fivepep) %>%
    mutate(em_go = str_replace_all(em_go, pattern = ",", replacement = "; "))
```
## BLASTP against UniProt


* Use the UniProtKB BLAST web search on each peptide, one-by-one
* Parameters
    - Target database: UniProtKB
    - E-Threshold: 10
    - Matrix: Auto
    - Filtering: None
    - Gapped: Yes
    - Hits: 50
* For each peptide, download the result list and get all GO terms and TaxID associated with that peptide
* To match Unipept, annotate each peptide with only the GO terms that are present in 5% or more of the proteins
* Get the most frequent protein name
* For taxonomy, we can also calculate the lowest common ancestor of each peptide (TODO)

```{r}
peptide <- rep(0, 5)
blast_go <- rep(0, 5)
files <- list.files('results/uniprot_blastp')
for (i in 1:5){
    peptide[i] <- fivepep[i]
    result <- read.delim(paste('results/uniprot_blastp/', paste(fivepep[i], '.tab', sep=""), sep="/"),
                   stringsAsFactors = FALSE,
                   na.strings = c("", "NA", "NaN"))
    gos <- table(unlist(str_split(result$Gene.ontology.IDs, "; ")))/50
    blast_go[i] <- paste(names(gos)[which(gos > 0.05)], collapse = "; ")
}
blast <- data.frame(peptide, blast_go, stringsAsFactors = FALSE)
```

### MetaGOmics

* Upload HOMD to metaGOmics
* Parameters:
    - Uniprot database: Uniprot sprot
    - Blast e-value cutoff: 1e-10
    - Use only top hit?: TRUE
* Result URL: https://www.yeastrc.org/metagomics/viewUploadedFasta.do?uid=qeZUp8gtIJDc4Sgh
* One-by-one, upload peptides and run
* Download results individually, combine into table

```{r}
# Creates the input files for metaGOmics i.e., single peptide with spectral count (# of validated PSMs)
#go_input <- select(fivepep_df, sequence, counts)
#for (i in 1:nrow(go_input)){
#  write.table(go_input[i,], paste('Data/metaGOmics/', go_input[i,]$sequence,".txt", sep=""), 
#            sep="\t", eol = "\r\n", quote=FALSE, row.names=FALSE, col.names=FALSE)
#}

peptide <- rep(0, 5)
mg_go <- rep(0, 5)
dir <- 'results/metaGOmics/'
files <- list.files(dir)
for (i in 1:5){
    peptide[i] <- fivepep[i]
    result <- read.delim(paste(dir, paste(fivepep[i], '.txt', sep=""), sep=""),
                   stringsAsFactors = FALSE,
                   na.strings = c("", "NA", "NaN"),
                   comment.char = "#")
    gos <- result$GO.acc
    mg_go[i] <- paste(gos, collapse = "; ")
}
mg <- data.frame(peptide, mg_go, stringsAsFactors = FALSE)
```


### Get the proteins and GO terms (for UPS) associated with the peptides
```{r}
# Takes the Uniprot-derived GO terms for UPS proteins
ups_go_df <- read.csv('data/uniprot-UPS-go-terms.tab', sep = "\t",
                stringsAsFactors = FALSE) %>%
  select(protein = Entry,
         ups_go = Gene.ontology.IDs)

pepprots <- select(peptide_report, proteins, peptide = sequence) %>%
  filter(peptide %in% fivepep) %>%
  mutate(protein = str_extract(proteins,"[A-Z0-9]+")) %>%
  select(protein, peptide)
pepprots <- plyr::join_all(list(pepprots, ups_go_df), by = "protein")
pepprots
```


### Combine all of the results:
```{r}
all_results <- plyr::join_all(list(pepprots, em, blast, mg, uni), by = "peptide")
all_results
```


All of the results are below:

```{r results = 'asis'}
library(pander)
# knitr::kable(all_results)
pander::pander(all_results, split.cell = 80, split.table = Inf)
```

## Let's go through the peptides one-by-one

Let's go through this UPS peptide:
```{r}
n <- 1
uniprot <- str_split(all_results[n, 'ups_go'], "; ", simplify=TRUE)
buni <- str_split(all_results[n, 'blast_go'], "; ", simplify=TRUE)
em <- str_split(all_results[n, 'em_go'], "; ", simplify=TRUE)
mg <- str_split(all_results[n, 'mg_go'], "; ", simplify=TRUE)
all_results[n, 'peptide']
all_results[n, 'protein']
```

It has a few GO terms taken from UniProt's UPS protein. It has this many GO terms:
```{r}
length(uniprot)
#setdiff(unlist(get_children(ancestors)), ancestors)
```

Based on this peptide, unipept analysis provides us adequate coverage, but it does not cover all UniProt terms. 
Let's check if all of Unipept's terms are contained within the UniProt set.
```{r}
length(buni) == length(intersect(buni, uniprot))
```
Here's how many GO terms are covered by Unipept:
```{r}
length(intersect(buni, uniprot))
length(uniprot)
paste(formatC(length(intersect(buni, uniprot)) / length(uniprot) * 100), "%", sep="")
```


Conversely, metaGOmics and eggNOG mapper have a lot of GO terms:
```{r}
length(em)
length(mg)
```

MetaGOmics seems to cover all the UPS terms:
```{r}
length(uniprot) == length(intersect(uniprot, mg))
```
EggNOG mapper doesn't, but it seems to cover more than Unipept.
```{r}
length(ups) == length(intersect(uniprot, em))
exclus_buni <- setdiff(unlist(intersect(uniprot, buni)),
                intersect(uniprot, em))
exclus_em <- setdiff(unlist(intersect(uniprot, em)),
              intersect(uniprot, buni))
print("BLAST/Unipept exclusive:")
length(intersect(uniprot, buni))
get_go_names(exclus_buni)
exclus_buni
print("")

print("EggNOG exclusive:")
length(intersect(uniprot, em))
get_go_names(exclus_em)
exclus_em
#intersect(buni)
```

Extraneous terms
```{r}
### Get distance -->
get_paths <- function(from, to){
     base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
     from_clean <- str_replace(from, ":", "%3A")
     to_clean <- str_replace(to, ":", "%3A")
     term_url <- paste(base_url, from_clean,
                       "/paths/", to_clean, "?relations=is_a", sep="")
     paths <- GET(term_url, accept("application/json"))
     json <- toJSON(content(paths))
     names <- fromJSON(json)$results
     names
}

shortest_path <- function(go1, go2){
  if (go1 == go2){
    'NA'
  } else{
     paths1_2 <- get_paths(go1, go2)
     paths2_1 <- get_paths(go2, go1)
     paths <- c(paths1_2, paths2_1)
     print(paths)
     if (length(paths1_2) + length(paths2_1) == 0){
       'NA'
     } else {
       min(sapply(paths, nrow))
     }
  }
}

map_paths <- function(x, terms){
  #print(terms)
  paste(terms)
  paths <- list()
  for (i in 1:length(terms)){
    result <- shortest_path(x, terms[i])
    if (result != 'NA'){
      path <- paste(terms[i], '(', result,')', sep='')
      paths <- rbind(paths, path)
    }
  }
  print(paste(paths, collapse=";"))
}
```


```{r}
eggnog_list <- c(str_split(all_results[n, 'em_go'], "; ", simplify =TRUE))
descendants <- get_go_descendants(buni_split)
ancestors <- get_go_ancestors(buni_split)
children_of_ancestors <- setdiff(unlist(get_children(ancestors)), ancestors)
em_ancestors_kids <- intersect(eggnog_list, children_of_ancestors)
closely_related <- union_all(buni_split, descendants, ancestors, children_of_ancestors)
em_extraneous <- setdiff(eggnog_list, closely_related)
em_ancestors_kids
```


```{r}
paths_em_extr <- data.frame(em_extraneous)
for (i in 1:length(em_extraneous)){
  paths_em_extr$paths[i] <- map_paths(em_extraneous[i], em_ancestors_kids)
}
# for (i in 1:length(em_extraneous)){
# paths_em_extr$uniprot_paths[i] <- map_paths(em_extraneous[i], uniprot)
# }
paths_em_extr
```
```{r}
intersect(uniprot, em_extraneous)
```




# GO:0005840 from BLAST/Unipept
# Extraneous: GO:0043228
# Ancestor's kid: GO:0005819
# map_paths("GO:0005840", "GO:0005819") -> nothing
#map_paths("GO:0005840", "GO:0043228") # -> 2 nodes away
#map_paths("GO:0043228", "GO:0005819")
#map_paths("GO:005819", )

#ancestors <- get_go_ancestors(buni_split)
#children_of_ancestors <- setdiff(unlist(get_children(ancestors)), ancestors)
#em_ancestors_kids <- intersect(eggnog_list, children_of_ancestors)
#intersect(em_extraneous,uniprot)



This is the metaGOmics list:
```{r}
metaGOmics_list <- c(str_split(all_results[n, 'mg_go'], "; ", simplify=TRUE))
```

And eggNOG
```{r}
eggnog_list <- c(str_split(all_results[n, 'em_go'], "; ", simplify =TRUE))
```

Let's go to the QuickGO API to get the names of the 4 BLAST/Unipept terms.
```{r}
library(httr)
library(jsonlite)
buni_split <- str_split(buni, "; ", simplify = TRUE)
get_go_names <- function(id_vector){
    base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
    terms <- str_replace(id_vector, ":", "%3A")
    joined_terms <- paste(terms, collapse="%2C")
    term_url <- paste(base_url, joined_terms, sep="")
    term_info <- GET(term_url, accept("application/json"))
    json <- toJSON(content(term_info))
    names <- unlist(fromJSON(json)$results$name)
    names
}
get_go_names(buni_split)
```

On the other hand, both eggNOG mapper and metaGOmics give huge lists of GO terms. Are the 4 BLAST+Unipept terms contained in these lists?

Does eggnog mapper contain all 4?
```{r}
em_buni <- intersect(eggnog_list, buni_split)
em_num_buni <- length(em_buni)
em_num_buni == 4
```

Does metagomics contain all 4?
```{r}
mg_buni <- intersect(metaGOmics_list, buni_split)
mg_num_buni <- length(mg_buni)
mg_num_buni == 4
```

The question is, then, what the other terms are.

The other terms could be related to the 4 we found in several ways:

1) They could be more general terms (ancestors)  of the 4 we found
2) They could be more specific terms (descendants) of the 4 we found
3) They could be terms that are not ancestors or descendants. These may be 'extraneous' GO terms.

However, we can also consider that terms that are not ancestors or descendants can be either closely or distantly related to the 4 we found. For this analysis, let's define 'closely related' as 'an ancestor, descendant, or child of ancestor' of the 4 terms. Terms that are not closely related are declared to be extraneous. So, we have 5 categories:

1) original terms (BLAST terms)
2) ancestors
3) descendants
4) children of ancestors
5) extraneous

Let's look at each of the latter 4 categories in turn (we already determined that 4 of each of the metaGOmics and eggNOG mapper terms are the 4 BLAST/Unipept terms).

### Ancestors
```{r}
# get all ancestors of the 4 terms
get_go_ancestors <- function(id_vector){
    base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
    terms <- str_replace(id_vector, ":", "%3A")
    joined_terms <- paste(terms, collapse="%2C")
    term_url <- paste(base_url, joined_terms, '/ancestors?relations=is_a', sep="")
    term_info <- GET(term_url, accept("application/json"))
    json <- toJSON(content(term_info))
    names <- unlist(fromJSON(json)$results$ancestors)
    names
}
ancestors <- get_go_ancestors(buni_split)
head(get_go_names(ancestors))
```

Now, let's look at the overlap between the ancestors and eggnog mapper, and between the ancestors and metaGOmics:

eggnog mapper
```{r}
em_ancestors <- intersect(eggnog_list, ancestors)
em_num_ancestors <- length(em_ancestors)
em_num_ancestors
```

metagomics
```{r}
mg_ancestors <- intersect(metaGOmics_list, ancestors)
mg_num_ancestors <- length(mg_ancestors)
mg_num_ancestors
```

### Descendants

```{r}
# get all childen of the 4 terms
get_go_descendants <- function(id_vector){
    base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
    terms <- str_replace(id_vector, ":", "%3A")
    joined_terms <- paste(terms, collapse="%2C")
    term_url <- paste(base_url, joined_terms, '/descendants?relations=is_a', sep="")
    term_info <- GET(term_url, accept("application/json"))
    json <- toJSON(content(term_info))
    names <- unlist(fromJSON(json)$results$descendants)
    names
}
descendants <- get_go_descendants(buni_split)
head(get_go_names(descendants))
```

eggNOG overlap with descendants:
```{r}
em_descendants <- intersect(descendants, eggnog_list)
em_num_descendants <- length(em_descendants)
em_num_descendants
```

MetaGOmics overlap:
```{r}
mg_descendants <- intersect(descendants, metaGOmics_list)
mg_num_descendants <- length(mg_descendants)
mg_num_descendants
```


### Children of ancestors

Function to get children
```{r}
get_children <- function(goids){
    base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
    terms <- str_replace(goids, ":", "%3A")
    joined_terms <- paste(terms, collapse="%2C")
    term_url <- paste(base_url, joined_terms, sep="")
    term_info <- GET(term_url, accept("application/json"))
    json <- toJSON(content(term_info))
    children <- fromJSON(json)$results$children
    children_is_a <- lapply(children, function(x) unlist(x[x$relation == "is_a", ]$id))
    return(children_is_a)
}
```

Get children of ancestors (that are not ancestors):

```{r}
children_of_ancestors <- setdiff(unlist(get_children(ancestors)), ancestors)
```

Get overlap.

EggNOG mapper:
```{r}
em_ancestors_kids <- intersect(eggnog_list, children_of_ancestors)
em_num_ancestors_kids <- length(em_ancestors_kids)
em_num_ancestors_kids
```

MetaGOmics
```{r}
mg_ancestors_kids <- intersect(metaGOmics_list, children_of_ancestors)
mg_num_ancestors_kids <- length(mg_ancestors_kids)
mg_num_ancestors_kids
```

### Extraneous

So, the terms that are designated 'extraneous' are those that remain.

We define the set of closely related terms below, then look at each tool to see how many terms are closely related.
```{r}
closely_related <- union_all(buni_split, descendants, ancestors, children_of_ancestors)
```

#### Eggnog Mapper
```{r}
em_extraneous <- setdiff(eggnog_list, closely_related)
em_num_extraneous <- length(em_extraneous)
em_num_extraneous
em_extraneous
```

#### MetaGOmics
```{r}
mg_extraneous <- setdiff(metaGOmics_list, closely_related)
mg_num_extraneous <- length(mg_extraneous)
mg_num_extraneous
mg_extraneous
```

## Results

Let's look at the full distribution of terms in the five categories for each of eggnog mapper and metaGOmics. 

```{r}
term_df <- data.frame(
    typeOfTerm = rep(c("blast_and_unipept", "descendants", "ancestors", "ancestors_kids", "extraneous"), 2),
    NumTerms = c(em_num_buni, em_num_descendants, em_num_ancestors, em_num_ancestors_kids, em_num_extraneous,
             mg_num_buni, mg_num_descendants, mg_num_ancestors, mg_num_ancestors_kids, mg_num_extraneous),
    Tool = rep(c("eggnog_mapper", "metagomics"), each = 5)
)
library(ggplot2)
ggplot(term_df) +
    geom_bar(aes(x = Tool, y = NumTerms, fill = typeOfTerm), color = "black", stat = "identity") +
    theme_bw()
```

```{r}
head(get_go_names(em_buni))
head(get_go_names(mg_buni))
em_buni
```

```{r}
setdiff(unlist(c("yo","gabba")), "gabba")
```

```{r}
library(ggplot2)
output <- data.frame(Peptide = all_results[,'peptide'],
                     Uniprot = all_results[,'ups_go'],
                     BLAST = character(n),
                     Unipept = character(n),
                     Equal = logical(n),
                     stringsAsFactors = FALSE)
for (n in 1:1){
# for (n in 1:nrow(all_results)){
  blast <- str_split(all_results[n, 'blast_go'], "; ", simplify=TRUE)
  uni <- c(str_split(all_results[n, 'uni_go_bp'], ";", simplify=TRUE),
         str_split(all_results[n, 'uni_go_mf'], ";", simplify=TRUE),
         str_split(all_results[n, 'uni_go_cc'], ";", simplify=TRUE))
  blast <- blast[blast != ""]
  
  uni <- uni[uni != ""]
  buni <- blast
  buni_split <- str_split(buni, ";", simplify = TRUE)
  metaGOmics_list <- c(str_split(all_results[n, 'mg_go'], "; ", simplify=TRUE))
  eggnog_list <- c(str_split(all_results[n, 'em_go'], "; ", simplify =TRUE))

  ancestors <- get_go_ancestors(buni_split)
    ancestors <- setdiff(unlist(ancestors), buni_split)
  descendants <- get_go_descendants(buni_split)
    descendants <- setdiff(unlist(descendants), buni_split)
  children_of_ancestors <- setdiff(unlist(get_children(ancestors)), ancestors)
  closely_related <- union_all(buni_split, descendants, ancestors, children_of_ancestors)
  #head(get_go_names(ancestors))
  #head(get_go_names(descendants))

  em_ancestors <- intersect(eggnog_list, ancestors)
    em_num_ancestors <- length(em_ancestors)
  mg_ancestors <- intersect(metaGOmics_list, ancestors)
    mg_num_ancestors <- length(mg_ancestors)
  em_descendants <- intersect(descendants, eggnog_list)
    em_num_descendants <- length(em_descendants)
  mg_descendants <- intersect(descendants, metaGOmics_list)
    mg_num_descendants <- length(mg_descendants)
  em_ancestors_kids <- intersect(eggnog_list, children_of_ancestors)
    em_ancestors_kids <- setdiff(unlist(em_ancestors_kids), buni_split)
    em_num_ancestors_kids <- length(em_ancestors_kids)
  mg_ancestors_kids <- intersect(metaGOmics_list, children_of_ancestors)
    mg_ancestors_kids <- setdiff(unlist(mg_ancestors_kids), buni_split)
    mg_num_ancestors_kids <- length(mg_ancestors_kids)
  
  em_extraneous <- setdiff(eggnog_list, closely_related)
    em_num_extraneous <- length(em_extraneous)
  mg_extraneous <- setdiff(metaGOmics_list, closely_related)
    mg_num_extraneous <- length(mg_extraneous)
  
  output$BLAST[n] <- all_results[n, 'blast_go']
  output$Unipept[n] <- paste(uni, collapse="; ")
  output$Equal[n] <- setequal(uni, blast)
  output$em.extraneous[n] <- paste(em_extraneous, collapse="; ")
  output$mg.extraneous[n] <- paste(mg_extraneous, collapse="; ")
  output$em.ancestors.kids[n] <- paste(em_ancestors_kids, collapse="; ")
  output$mg.ancestors.kids[n] <- paste(mg_ancestors_kids, collapse="; ")
  #output$em.paths[n] <- calc_paths(em_extraneous, em_ancestors_kids)
  #output$mg.paths[n] <- calc_paths(mg_extraneous, mg_ancestors_kids)
  
  output$em.ancestors[n] <- paste(em_ancestors, collapse="; ")
  output$mg.ancestors[n] <- paste(mg_ancestors, collapse="; ")
  output$em.descendants[n] <- paste(em_descendants, collapse="; ")
  output$mg.descendants[n] <- paste(mg_descendants, collapse="; ")
  #output$em.ancestors[n] <- length(em_ancestors)
  #output$mg.ancestors[n] <- length(mg_ancestors)
  #output$em.descendants[n] <- length(em_descendants)
  #output$mg.descendants[n] <- length(mg_descendants)
  #output$em.ancestors.kids[n] <- length(em_ancestors_kids)
  #output$mg.ancestors.kids[n] <- length(mg_ancestors_kids)
  em_buni <- intersect(eggnog_list, buni)
    em_num_buni <- length(em_buni)
  mg_buni <- intersect(metaGOmics_list, buni)
    mg_num_buni <- length(mg_buni)
  
  term_df <- data.frame(
    typeOfTerm = rep(c("blast_and_unipept", "descendants", "ancestors", "ancestors_kids", "extraneous"), 2),
    NumTerms = c(em_num_buni, em_num_descendants, em_num_ancestors, em_num_ancestors_kids, em_num_extraneous,
             mg_num_buni, mg_num_descendants, mg_num_ancestors, mg_num_ancestors_kids, mg_num_extraneous),
    Tool = rep(c("eggnog_mapper", "metagomics"), each = 5)
  )
  plot <- ggplot(term_df) +
    geom_bar(aes(x = Tool, y = NumTerms, fill = typeOfTerm), color = "black", stat = "identity") +
    theme_bw()
  # plot_em <- pie(c(em_num_buni, em_num_descendants, em_num_ancestors, em_num_ancestors_kids, em_num_extraneous), 
  #     labels = c("blast_and_unipept", "descendants", "ancestors", "ancestors_kids", "extraneous"),
  #     main=paste("EggNOG\n", all_results[n,'peptide']))
  # plot_mg <- pie(c(mg_num_buni, mg_num_descendants, mg_num_ancestors, mg_num_ancestors_kids, mg_num_extraneous), 
  #     labels = c("blast_and_unipept", "descendants", "ancestors", "ancestors_kids", "extraneous"),
  #     main=paste("MetaGOmics\n", all_results[n,'peptide']))
  print(plot)
  #print(plot_em)
  #print(plot_mg)
}
#pander::pander(output, split.cell = 10, split.table = Inf)
```

```{r}
#shortest_path("GO:0003723", "GO:0065007")
#get_go_ancestors("GO:0065007")
#get_go_names(get_go_ancestors("GO:0008150"))
terms <- str_split(output$Uniprot[1], '; ', simplify = TRUE)
terms
get_go_names(terms)
```


```{r}
# Check if there is no overlap between categories
n <- 1
length(str_split(output$BLAST[n],'; ', simplify=TRUE)) + length(str_split(output$em.descendants[n],'; ', simplify=TRUE)) +
length(str_split(output$em.ancestors[n],'; ', simplify=TRUE)) + length(str_split(output$em.ancestors.kids[n],'; ', simplify=TRUE)) +
length(str_split(output$em.extraneous[n],'; ', simplify=TRUE))
#== length(eggnog_list)
length(eggnog_list)
```

```{r}
terms <- str_split(output$em.ancestors[1], "; ", simplify = TRUE)
print(terms)
print(get_go_names(terms))
```


```{r}
#shortest_path("GO:0014059","GO:0008344")
#get_go_names(c("GO:0014059","GO:0046928"))
# Behavior: GO:0007610
# Locomotory behavior: GO:0007626
# Adult behavior: GO:0030534
# Adult locomotory behavior: GO:0008344
#shortest_path("GO:0008344", "GO:0030534")
#shortest_path("GO:0007626","GO:0030534")
#term <- "GO:0043005"
#get_go_names(term)
#get_go_names(get_go_ancestors(term))
```


<!-- Calculate proportions to answer three questions: -->
<!-- 1) How many of Uniprot's terms does the tool pick up? -->
<!-- 2) What is the proportion of total terms from the tool that are extraneous? -->

<!-- #### Eggnog -->
<!-- ```{r} -->
<!-- # answer to 1 -->
<!-- length(intersect(eggnog_list, buni_split)) / length(buni_split) -->

<!-- # answer to 2 -->
<!-- length(em_diff_with_kids)/length(eggnog_list) -->
<!-- ``` -->

<!-- #### MetaGOmics -->
<!-- ```{r} -->
<!-- # answer to 1 -->
<!-- length(intersect(metaGOmics_list, buni_split)) / length(buni_split) -->

<!-- # answer to 2 -->
<!-- length(mg_diff_with_kids)/length(metaGOmics_list) -->
<!-- ``` -->


<!-- metaGOmics -->
<!-- ```{r} -->
<!-- diff <- setdiff(metaGOmics_list, full_tree) -->
<!-- get_go_names(diff) -->
<!-- ``` -->

<!-- eggNOG mapper -->
<!-- ```{r} -->
<!-- em_diff <- setdiff(eggnog_list, full_tree) -->
<!-- get_go_names(em_diff) -->
<!-- ``` -->

<!-- Visualize the overlap between the full Blast+Unipept tree (descendants, ancestors) and the eggNOG and metaGOmics term lists. -->
<!-- ```{r fig.width=4, fig.height=4} -->
<!-- library(VennDiagram) -->
<!-- grid.newpage() -->
<!-- grid.draw(venn.diagram( -->
<!--     list("eggnog" = eggnog_list, "blast+unipept" = full_tree, "metagomics" = metaGOmics_list), -->
<!--     NULL)) -->
<!-- file.remove(list.files(pattern = "VennDiagram.*log")) # venn diagram log files -->
<!-- ``` -->

<!-- ## Future directions -->
<!-- 1) repeat this for the other 4 peptides -->
<!-- 2) how do we handle terms that are not descendants or ancestors? We could define some distance cutoff, and say that everything beyond that is a false hit. For example, we could say that if the shortest path between a metaGOmics or eggNOG term and any term in the full B+U tree has length greater than or equal to 2 than it is a false hit. -->

<!-- ### Get distance -->
<!-- ```{r} -->
<!-- get_paths <- function(from, to){ -->
<!--     base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/' -->
<!--     from_clean <- str_replace(from, ":", "%3A") -->
<!--     to_clean <- str_replace(to, ":", "%3A") -->
<!--     term_url <- paste(base_url, from_clean, -->
<!--                       "/paths/", to_clean, "?relations=is_a", sep="") -->
<!--     paths <- GET(term_url, accept("application/json")) -->
<!--     json <- toJSON(content(paths)) -->
<!--     names <- fromJSON(json)$results -->
<!--     names -->
<!-- } -->

<!-- shortest_path <- function(go1, go2){ -->
<!--     paths1_2 <- get_paths(go1, go2) -->
<!--     paths2_1 <- get_paths(go2, go1) -->
<!--     paths <- c(paths1_2, paths2_1) -->
<!--     min(sapply(paths, length)) -->
<!-- } -->

<!-- shortest_path("GO:1901136", "GO:0008150") -->
<!-- ``` -->

<!-- ## GO glossary -->

<!-- Here, I get the names of all the above GO terms. -->

<!-- ``` -->
<!-- library(httr) -->
<!-- library(jsonlite) -->
<!-- base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/' -->
<!-- term_url <- paste(base_url, 'GO%3A0008150%2CGO%3A0008152', sep="") -->
<!-- term_info <- GET(term_url, verbose(), accept("application/json")) -->
<!-- json <- toJSON(content(term_info)) -->
<!-- df <- fromJSON(json)$results -->
<!-- ``` -->