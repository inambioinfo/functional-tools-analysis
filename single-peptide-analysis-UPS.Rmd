---
title: "Single Peptide Results Analysis - UPS Dataset"
author: "Caleb Easterly and Ray Sajulga"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```
**September 17, 2018**
## Introduction
Analysis adapted from Caleb Easterly's "Single Peptide Results Analysis" (https://github.com/caleb-easterly/single_peptide) for the UPS dataset.

---

Let's get the dynamic amounts for each UPS protein
```{r}
library(dplyr)
library(stringr)
ups_ratios <- read.csv("UPS-Protein-Ratios.tsv", sep = "\t",
                header = TRUE, stringsAsFactors = FALSE) %>%
  select(ups2_amount = UPS2.Amount..fmol.,
         protein = UniProt.Accession.Number)
```

### Peptide Sampling
Let's randomly select 20 UPS peptides from the UPS1 dataset (replicate #3):

```{r}
# Obtains peptide report
peptide_report <- read.csv("Data/UPS/UPS1/UPS1_03_[Peptide_Shaker_on_data_21__Peptide_Report].tabular",
         sep = "\t", comment.char="", header = TRUE, stringsAsFactors = FALSE) %>%
  select(proteins = Protein.s.,
         sequence = Sequence,
         counts = X.Validated.PSMs)

# Extracts the UPS peptide rows
ups_peptides <- filter(peptide_report, grepl("ups", proteins)) %>%
  mutate(protein = str_extract(proteins, "[A-Z][0-9]+")) %>%
  filter(protein %in% ups_ratios$protein)

# Randomly selects 20 peptides
set.seed(1003)
ups_peptides <- ups_peptides[sample(nrow(ups_peptides), 20),]
peptides <- ups_peptides$sequence

# Writes out twenty peptides in a text file for analysis
write.table(peptides, "twenty_peptides.txt", 
            sep="\n", quote=FALSE, row.names=FALSE, col.names=FALSE)
```

### Unipept

#### Process
* Paste the tabular list of peptides into the Unipept ‘Metaproteomics Analysis’ web application (https://morty.ugent.be/mpa)  
* Parameters:
    - Equate I and L: FALSE
    - Filter duplicate peptides: FALSE
    - Advanced missed cleavage handling: TRUE
* Download results
* Annotate each peptide with only the GO terms that are present in 5% or more of the proteins (percentages are returned in GO term column)

```{r}
cov_pat <- "\ \\(.{2,4}\\)"
uni <- read.csv('results/unipept/UPS_03-Unipept-20pep-1003seed.csv',
                stringsAsFactors = FALSE) %>%
    select(peptide,
           uni_go_bp = GO..biological.process.,
           uni_go_mf = GO..molecular.function.,
           uni_go_cc = GO..cellular.component.) %>%
    mutate(uni_go_bp = str_replace_all(string = uni_go_bp, pattern = cov_pat, replacement = ""),
           uni_go_mf = str_replace_all(string = uni_go_mf, pattern = cov_pat, replacement = ""),
           uni_go_cc = str_replace_all(string = uni_go_cc, pattern = cov_pat, replacement = ""))
```



### eggNOG mapper
* Use the Galaxy version of eggNOG mapper, on Galaxy-P
* Parameters:
    - Annotation type: DIAMOND
    - Scoring matrix and gap costs: PAM30, 9 and 1
    - Taxonomic Scope: Mammals
    - Orthologs: use all orthologs
    - Gene Ontology evidence: use non-electronic terms
    - Seed Orthology Search Options
        - Min e-value: 200000
        - Min bit score: 20
* Download and compare GO terms
  
```{r}
em <- read.delim("results/eggNOG/eggnog_mapper_20_sequences_results_seed-1003.tabular",
                 stringsAsFactors = FALSE,
                 header=FALSE) %>%
    select(peptide = V1, em_prot = V2, em_go = V6, em_gene = V5, em_descript = V13) %>%
    mutate(em_go = str_replace_all(em_go, pattern = ",", replacement = "; "))
```
## BLASTP against UniProt


* Use the UniProtKB BLAST web search on each peptide, one-by-one
* Parameters
    - Target database: UniProtKB
    - E-Threshold: 10
    - Matrix: Auto
    - Filtering: None
    - Gapped: Yes
    - Hits: 50
* For each peptide, download the result list and get all GO terms and TaxID associated with that peptide
* To match Unipept, annotate each peptide with only the GO terms that are present in 5% or more of the proteins
* Get the most frequent protein name
* For taxonomy, we can also calculate the lowest common ancestor of each peptide (TODO)

```{r}
blast_go <- rep(0, length(peptides))
files <- list.files('results/uniprot_blastp')
for (i in 1:length(peptides)){
    result <- read.delim(paste('results/uniprot_blastp/', paste(peptides[i], '.tab', sep=""), sep="/"),
                   stringsAsFactors = FALSE,
                   na.strings = c("", "NA", "NaN"))
    gos <- table(unlist(str_split(result$Gene.ontology.IDs, "; ")))/50
    blast_go[i] <- paste(names(gos)[which(gos > 0.05)], collapse = "; ")
}
blast <- data.frame(peptide = peptides, blast_go, stringsAsFactors = FALSE)
```

### MetaGOmics

* Upload HOMD to metaGOmics
* Parameters:
    - Uniprot database: Uniprot sprot
    - Blast e-value cutoff: 1e-10
    - Use only top hit?: TRUE
* Result URL: https://www.yeastrc.org/metagomics/viewUploadedFasta.do?uid=qeZUp8gtIJDc4Sgh
* One-by-one, upload peptides and run
* Download results individually, combine into table

```{r}
##Creates the input files for metaGOmics i.e., single peptide with spectral count (# of validated PSMs)
# go_input <- select(ups_peptides, sequence, counts)
# for (i in 1:nrow(go_input)){
#  write.table(go_input[i,], paste('Data/metaGOmics/', go_input[i,]$sequence,".txt", sep=""),
#          sep="\t", eol = "\r\n", quote=FALSE, row.names=FALSE, col.names=FALSE)
# }
```


```{r}
mg_go <- rep(0, length(peptides))
dir <- 'results/metaGOmics/'
files <- list.files(dir)
for (i in 1:length(peptides)){
    result <- read.delim(paste(dir, paste(peptides[i], '.txt', sep=""), sep=""),
                   stringsAsFactors = FALSE,
                   na.strings = c("", "NA", "NaN"),
                   comment.char = "#")
    gos <- result$GO.acc
    mg_go[i] <- paste(gos, collapse = "; ")
}
mg <- data.frame(peptide = peptides, mg_go, stringsAsFactors = FALSE)
```


### Get the proteins and UniProtKB GO terms (for UPS) associated with the peptides
```{r}
# Takes the Uniprot-derived GO terms for UPS proteins
ups_go_df <- read.csv('data/uniprot-UPS-go-terms.tab', sep = "\t",
                stringsAsFactors = FALSE) %>%
  select(protein = Entry,
         ups_go = Gene.ontology.IDs)
pepprots <- unique(select(peptide_report, proteins, peptide = sequence) %>%
  filter(peptide %in% peptides) %>%
  mutate(protein = str_extract(proteins,"[A-Z0-9]+")) %>%
  select(protein, peptide))
pepprots <- plyr::join_all(list(pepprots, ups_go_df), by = "protein")
pepprots
```

### Which protein has the fewest and greatest amount of GO terms?
```{r}
ups_go_term_counts <- mutate(pepprots, count = as.numeric(sapply(ups_go, function(x) length(str_split(x, "; ", simplify=TRUE)))))
lgt_ups <- ups_go_term_counts[ups_go_term_counts$count == min(ups_go_term_counts$count),]
#ups_go_term_counts
lgt_ups$protein # Least GO Terms UPS
lgt_ups$peptide
lgt_ups$count
#lgt_ups$ups_go
mgt_ups <- ups_go_term_counts[ups_go_term_counts$count == max(ups_go_term_counts$count),]
mgt_ups$protein # Most GO Terms UPS
mgt_ups$peptide
mgt_ups$count
```



### Combine all of the results:
```{r}
all_results <- plyr::join_all(list(pepprots, em, blast, mg, uni), by = "peptide")
```


All of the results are below:

```{r results = 'asis'}
library(pander)
# knitr::kable(all_results)
#pander::pander(all_results, split.cell = 80, split.table = Inf)
```

## Let's go through the peptides one-by-one

Let's analyze each peptide one-by-one, starting with the peptide with the fewest amount of UniProtKB-derived GO terms
```{r}
n <-13
uniprot <- str_split(all_results[n, 'ups_go'], "; ", simplify=TRUE)
blast <- str_split(all_results[n, 'blast_go'], "; ", simplify=TRUE)
uni <- c(str_split(all_results[n, 'uni_go_bp'], ";", simplify=TRUE),
         str_split(all_results[n, 'uni_go_mf'], ";", simplify=TRUE),
         str_split(all_results[n, 'uni_go_cc'], ";", simplify=TRUE))
em <- str_split(all_results[n, 'em_go'], "; ", simplify=TRUE)
mg <- str_split(all_results[n, 'mg_go'], "; ", simplify=TRUE)
paste(all_results[n, 'peptide'], 'from', all_results[n, 'protein'])
paste('Contains', length(uniprot), 'GO terms')


```

Let's check what these terms are:
```{r}
library(httr)
library(jsonlite)
get_go_names <- function(id_vector){
  if (length(id_vector) > 0){
    base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
    terms <- str_replace(id_vector, ":", "%3A")
    joined_terms <- paste(terms, collapse="%2C")
    term_url <- paste(base_url, joined_terms, sep="")
    term_info <- GET(term_url, accept("application/json"))
    json <- toJSON(content(term_info))
    names <- unlist(fromJSON(json)$results$name)
    names
  }
}
get_go_names(uniprot)
```

Let's get the ancestors of these UniProtKB terms
```{r}
# get all ancestors
get_go_ancestors <- function(id_vector){
    base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
    terms <- str_replace(id_vector, ":", "%3A")
    joined_terms <- paste(terms, collapse="%2C")
    term_url <- paste(base_url, joined_terms, '/ancestors?relations=is_a', sep="")
    term_info <- GET(term_url, accept("application/json"))
    json <- toJSON(content(term_info))
    names <- unlist(fromJSON(json)$results$ancestors)
    names
}
ancestors <- get_go_ancestors(uniprot)
get_go_names(sample(ancestors, 10))
```

Let's get the descendants of these UniProtKB terms
```{r}
# Gets all descendants
get_go_descendants <- function(id_vector){
    base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
    terms <- str_replace(id_vector, ":", "%3A")
    joined_terms <- paste(terms, collapse="%2C")
    term_url <- paste(base_url, joined_terms, '/descendants?relations=is_a', sep="")
    term_info <- GET(term_url, accept("application/json"))
    json <- toJSON(content(term_info))
    names <- unlist(fromJSON(json)$results$descendants)
    names
}
descendants <- get_go_ancestors(uniprot)
get_go_names(sample(descendants, 10))
```


Let's check how these GO terms are covered amongst these three groups:
```{r}
library(VennDiagram)
venn.plot <- draw.triple.venn(
  area1 = length(uniprot),
  area2 = length(blast),
  area3 = length(uni),
  n12 = length(intersect(uniprot, blast)),
  n23 = length(intersect(blast, uni)),
  n13 = length(intersect(uniprot, uni)),
  n123 = length(intersect(intersect(uniprot, uni), blast)),
  category = c("Uniprot", "BLAST", "Unipept"))
grid.draw(venn.plot)
grid.newpage()

```

Are the non-UniProtKB terms related (i.e., ancestors or descendants) to UniProtKB terms?
```{r}
unknown_go_uni <- setdiff(uni, intersect(uniprot, uni))
unknown_go_blast <- setdiff(blast, intersect(uniprot, blast))
if (length(unknown_go_uni) > 0){
  length(intersect(unknown_go_uni,ancestors)) > 0 || length(intersect(unknown_go_uni,descendants)) > 0
}
if (length(unknown_go_blast) > 0){
  length(intersect(unknown_go_blast,ancestors)) > 0 || length(intersect(unknown_go_blast,descendants)) > 0
}
```


```{r}
# UniProtKB should have more than BLAST and Unipept
length(uniprot) > length(blast) && length(uniprot) > length(uni)

# What proportion of the BLAST terms are contained by UniProtKB?
blast_prop <- length(intersect(uniprot, blast)) / length(blast)
blast_prop
if (blast_prop != 1){
  paste(get_go_names(setdiff(blast, intersect(uniprot, blast))),
    "= from BLAST is excluded in UniProtKB")
}

# What proportion of the Unipept terms are contained by UniProtKB?
uni_prop <- length(intersect(uniprot, uni)) / length(uni)
uni_prop
if (uni_prop != 1){
  paste(get_go_names(setdiff(uni, intersect(uniprot, uni))),
    "= from Unipept is excluded in UniProtKB")
}

# Unique to UniProtKB compared to BLAST
get_go_names(setdiff(uniprot, intersect(blast, uniprot)))
# Unique to UniProtKB compared to Unipept
get_go_names(setdiff(uniprot, intersect(uni, uniprot)))
# Unique to BLAST compared to Unipept
get_go_names(setdiff(blast, intersect(uni, blast)))


ancestors <- get_go_ancestors(uniprot)

#get_go_names(setdiff(uniprot, blast))
#get_go_names(setdiff(uniprot, uni))
#setdiff(uni, uniprot)
#length(buni) == length(intersect(buni, uniprot))
```

Conversely, metaGOmics and eggNOG mapper have a lot of GO terms:
```{r}
length(em)
length(mg)
```

MetaGOmics seems to cover all the UPS terms:
```{r}
length(uniprot) == length(intersect(uniprot, mg))
```

EggNOG mapper doesn't, but it seems to cover more than Unipept.
```{r}
length(uniprot) == length(intersect(uniprot, em))
exclus_buni <- setdiff(unlist(intersect(uniprot, buni)),
                intersect(uniprot, em))
exclus_em <- setdiff(unlist(intersect(uniprot, em)),
              intersect(uniprot, buni))
print("BLAST/Unipept exclusive:")
length(intersect(uniprot, buni))
get_go_names(exclus_buni)
exclus_buni
print("")

print("EggNOG exclusive:")
length(intersect(uniprot, em))
get_go_names(exclus_em)
exclus_em
#intersect(buni)
```

Extraneous terms

```{r}
eggnog_list <- c(str_split(all_results[n, 'em_go'], "; ", simplify =TRUE))
descendants <- get_go_descendants(buni_split)
ancestors <- get_go_ancestors(buni_split)
children_of_ancestors <- setdiff(unlist(get_children(ancestors)), ancestors)
em_ancestors_kids <- intersect(eggnog_list, children_of_ancestors)
closely_related <- union_all(buni_split, descendants, ancestors, children_of_ancestors)
em_extraneous <- setdiff(eggnog_list, closely_related)
em_ancestors_kids
```


```{r}
paths_em_extr <- data.frame(em_extraneous)
for (i in 1:length(em_extraneous)){
  paths_em_extr$paths[i] <- map_paths(em_extraneous[i], em_ancestors_kids)
}
# for (i in 1:length(em_extraneous)){
# paths_em_extr$uniprot_paths[i] <- map_paths(em_extraneous[i], uniprot)
# }
paths_em_extr
```
```{r}
intersect(uniprot, em_extraneous)
```




# GO:0005840 from BLAST/Unipept
# Extraneous: GO:0043228
# Ancestor's kid: GO:0005819
# map_paths("GO:0005840", "GO:0005819") -> nothing
#map_paths("GO:0005840", "GO:0043228") # -> 2 nodes away
#map_paths("GO:0043228", "GO:0005819")
#map_paths("GO:005819", )

#ancestors <- get_go_ancestors(buni_split)
#children_of_ancestors <- setdiff(unlist(get_children(ancestors)), ancestors)
#em_ancestors_kids <- intersect(eggnog_list, children_of_ancestors)
#intersect(em_extraneous,uniprot)



This is the metaGOmics list:
```{r}
metaGOmics_list <- c(str_split(all_results[n, 'mg_go'], "; ", simplify=TRUE))
```

And eggNOG
```{r}
eggnog_list <- c(str_split(all_results[n, 'em_go'], "; ", simplify =TRUE))
```

Let's go to the QuickGO API to get the names of the 4 BLAST/Unipept terms.
```{r}

get_go_names(buni_split)
```

On the other hand, both eggNOG mapper and metaGOmics give huge lists of GO terms. Are the 4 BLAST+Unipept terms contained in these lists?

Does eggnog mapper contain all 4?
```{r}
em_buni <- intersect(eggnog_list, buni_split)
em_num_buni <- length(em_buni)
em_num_buni == 4
```

Does metagomics contain all 4?
```{r}
mg_buni <- intersect(metaGOmics_list, buni_split)
mg_num_buni <- length(mg_buni)
mg_num_buni == 4
```

The question is, then, what the other terms are.

The other terms could be related to the 4 we found in several ways:

1) They could be more general terms (ancestors)  of the 4 we found
2) They could be more specific terms (descendants) of the 4 we found
3) They could be terms that are not ancestors or descendants. These may be 'extraneous' GO terms.

However, we can also consider that terms that are not ancestors or descendants can be either closely or distantly related to the 4 we found. For this analysis, let's define 'closely related' as 'an ancestor, descendant, or child of ancestor' of the 4 terms. Terms that are not closely related are declared to be extraneous. So, we have 5 categories:

1) original terms (BLAST terms)
2) ancestors
3) descendants
4) children of ancestors
5) extraneous

Let's look at each of the latter 4 categories in turn (we already determined that 4 of each of the metaGOmics and eggNOG mapper terms are the 4 BLAST/Unipept terms).

### Ancestors
```{r}
# get all ancestors of the 4 terms
get_go_ancestors <- function(id_vector){
    base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
    terms <- str_replace(id_vector, ":", "%3A")
    joined_terms <- paste(terms, collapse="%2C")
    term_url <- paste(base_url, joined_terms, '/ancestors?relations=is_a', sep="")
    term_info <- GET(term_url, accept("application/json"))
    json <- toJSON(content(term_info))
    names <- unlist(fromJSON(json)$results$ancestors)
    names
}
ancestors <- get_go_ancestors(buni_split)
head(get_go_names(ancestors))
```

Now, let's look at the overlap between the ancestors and eggnog mapper, and between the ancestors and metaGOmics:

eggnog mapper
```{r}
em_ancestors <- intersect(eggnog_list, ancestors)
em_num_ancestors <- length(em_ancestors)
em_num_ancestors
```

metagomics
```{r}
mg_ancestors <- intersect(metaGOmics_list, ancestors)
mg_num_ancestors <- length(mg_ancestors)
mg_num_ancestors
```

### Descendants

```{r}
# get all childen of the 4 terms
get_go_descendants <- function(id_vector){
    base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
    terms <- str_replace(id_vector, ":", "%3A")
    joined_terms <- paste(terms, collapse="%2C")
    term_url <- paste(base_url, joined_terms, '/descendants?relations=is_a', sep="")
    term_info <- GET(term_url, accept("application/json"))
    json <- toJSON(content(term_info))
    names <- unlist(fromJSON(json)$results$descendants)
    names
}
descendants <- get_go_descendants(buni_split)
head(get_go_names(descendants))
```

eggNOG overlap with descendants:
```{r}
em_descendants <- intersect(descendants, eggnog_list)
em_num_descendants <- length(em_descendants)
em_num_descendants
```

MetaGOmics overlap:
```{r}
mg_descendants <- intersect(descendants, metaGOmics_list)
mg_num_descendants <- length(mg_descendants)
mg_num_descendants
```


### Children of ancestors

Function to get children
```{r}
get_children <- function(goids){
    base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
    terms <- str_replace(goids, ":", "%3A")
    joined_terms <- paste(terms, collapse="%2C")
    term_url <- paste(base_url, joined_terms, sep="")
    term_info <- GET(term_url, accept("application/json"))
    json <- toJSON(content(term_info))
    children <- fromJSON(json)$results$children
    children_is_a <- lapply(children, function(x) unlist(x[x$relation == "is_a", ]$id))
    return(children_is_a)
}
#get_children(str_split("GO:0005575; GO:0005576", "; ", simplify=TRUE))
```

Get children of ancestors (that are not ancestors):

```{r}
children_of_ancestors <- setdiff(unlist(get_children(ancestors)), ancestors)
```

Get overlap.

EggNOG mapper:
```{r}
em_ancestors_kids <- intersect(eggnog_list, children_of_ancestors)
em_num_ancestors_kids <- length(em_ancestors_kids)
em_num_ancestors_kids
```

MetaGOmics
```{r}
mg_ancestors_kids <- intersect(metaGOmics_list, children_of_ancestors)
mg_num_ancestors_kids <- length(mg_ancestors_kids)
mg_num_ancestors_kids
```

### Extraneous

So, the terms that are designated 'extraneous' are those that remain.

We define the set of closely related terms below, then look at each tool to see how many terms are closely related.
```{r}
closely_related <- union_all(buni_split, descendants, ancestors, children_of_ancestors)
```

#### Eggnog Mapper
```{r}
em_extraneous <- setdiff(eggnog_list, closely_related)
em_num_extraneous <- length(em_extraneous)
em_num_extraneous
em_extraneous
```

#### MetaGOmics
```{r}
mg_extraneous <- setdiff(metaGOmics_list, closely_related)
mg_num_extraneous <- length(mg_extraneous)
mg_num_extraneous
mg_extraneous
```

## Results

Let's look at the full distribution of terms in the five categories for each of eggnog mapper and metaGOmics. 

```{r}
term_df <- data.frame(
    typeOfTerm = rep(c("blast_and_unipept", "descendants", "ancestors", "ancestors_kids", "extraneous"), 2),
    NumTerms = c(em_num_buni, em_num_descendants, em_num_ancestors, em_num_ancestors_kids, em_num_extraneous,
             mg_num_buni, mg_num_descendants, mg_num_ancestors, mg_num_ancestors_kids, mg_num_extraneous),
    Tool = rep(c("eggnog_mapper", "metagomics"), each = 5)
)
library(ggplot2)
ggplot(term_df) +
    geom_bar(aes(x = Tool, y = NumTerms, fill = typeOfTerm), color = "black", stat = "identity") +
    theme_bw()
```

```{r}
head(get_go_names(em_buni))
head(get_go_names(mg_buni))
em_buni
```


```{r}
all_results
```

```{r}
library(ggplot2)
n <- nrow(all_results)
output <- data.frame(Peptide = all_results[,'peptide'],
                     Uniprot = all_results[,'ups_go'],
                     BLAST = character(n),
                     Unipept = character(n),
                     Equal = logical(n),
                     stringsAsFactors = FALSE)
paths <- data.frame(Peptide = all_results[,'peptide'])
for (n in 13:13){
#for (n in 18:nrow(all_results)){
 if (n != 16){
   all_results[n,'peptide']
  blast <- str_split(all_results[n, 'blast_go'], "; ", simplify=TRUE)
  uni <- c(str_split(all_results[n, 'uni_go_bp'], ";", simplify=TRUE),
         str_split(all_results[n, 'uni_go_mf'], ";", simplify=TRUE),
         str_split(all_results[n, 'uni_go_cc'], ";", simplify=TRUE))
  blast <- blast[blast != ""]
  
  uni <- uni[uni != ""]
  buni <- blast
  #buni_split <- str_split(buni, ";", simplify = TRUE)
  buni_split <- str_split(all_results[n, 'ups_go'], "; ", simplify = TRUE)
  metaGOmics_list <- c(str_split(all_results[n, 'mg_go'], "; ", simplify=TRUE))
  eggnog_list <- c(str_split(all_results[n, 'em_go'], "; ", simplify =TRUE))
  ancestors <- get_go_ancestors(buni_split)
    ancestors <- setdiff(unlist(ancestors), buni_split)
  descendants <- get_go_descendants(buni_split)
    descendants <- setdiff(unlist(descendants), buni_split)
  children_of_ancestors <- setdiff(unlist(get_children(ancestors)), ancestors)
  closely_related <- union_all(buni_split, descendants, ancestors, children_of_ancestors)
  
  
  em_buni <- intersect(eggnog_list, buni_split)
  mg_buni <- intersect(metaGOmics_list, buni_split)
  em_ancestors <- intersect(eggnog_list, ancestors)
  mg_ancestors <- intersect(metaGOmics_list, ancestors)
  em_descendants <- intersect(descendants, eggnog_list)
  mg_descendants <- intersect(descendants, metaGOmics_list)
  em_ancestors_kids <- setdiff(unlist(intersect(eggnog_list, children_of_ancestors)), em_buni)
  mg_ancestors_kids <- setdiff(unlist(intersect(metaGOmics_list, children_of_ancestors)), mg_buni)
  em_extraneous <- setdiff(eggnog_list, closely_related)
  mg_extraneous <- setdiff(metaGOmics_list, closely_related)
  
  #output$BLAST[n] <- all_results[n, 'blast_go']
  
  #output$Unipept[n] <- paste(uni, collapse="; ")
  #output$Equal[n] <- setequal(uni, blast)
  
  output$em.list[n] <- paste(eggnog_list, collapse="; ")
  output$mg.list[n] <- paste(metaGOmics_list, collapse="; ")
  output$em.buni[n] <- paste(em_buni, collapse="; ")
  output$mg.buni[n] <- paste(mg_buni, collapse="; ")
  output$em.extraneous[n] <- paste(em_extraneous, collapse="; ")
  output$mg.extraneous[n] <- paste(mg_extraneous, collapse="; ")
  output$em.ancestors.kids[n] <- paste(em_ancestors_kids, collapse="; ")
  output$mg.ancestors.kids[n] <- paste(mg_ancestors_kids, collapse="; ")
  
  #paths$em.ancestors[n] <- average_paths(em_buni, em_extraneous)
  #paths$mg.ancestors[n] <- average_paths(mg_buni, mg_ancestors)
  #paths$em.extraneous.to.ancestors <- average_paths(em_buni, em_descendants)
  #paths$mg.extraneous.to.ancestors <- average_paths(mg_extraneous, mg_ancestors_kids)
  #paths$mg.extraneous.to.ancestors <- get_paths(mg_extraneous[1:5], mg_ancestors[1:5])
  #paths$mg.extraneous.to.ancestors <- average_paths(mg_buni, )
  
  # Path mapping
  #paths$em.extraneous.to.ancestors[n] <- paste(map_paths(em_extraneous, em_ancestors), collapse="; ")
  #paths$mg.extraneous.to.ancestors[n] <- paste(map_paths(mg_extraneous, mg_ancestors), collapse="; ")
  #paths$em.extraneous.to.ancestors.kids[n] <- paste(map_paths(em_extraneous, em_ancestors_kids), collapse="; ")
  #paths$mg.extraneous.to.ancestors.kids[n] <- paste(map_paths(mg_extraneous, mg_ancestors_kids), collapse="; ")
  #paths$em.uniprot.to.ancestors[n] <- paste(map_paths(em_buni, em_ancestors), collapse="; ")
  #paths$mg.uniprot.to.ancestors[n] <- paste(map_paths(mg_buni, mg_ancestors), collapse="; ")
  #paths$em.uniprot.to.descendants[n] <- paste(map_paths(em_buni, em_descendants), collapse="; ")
  #paths$mg.uniprot.to.descendants[n] <- paste(map_paths(mg_buni, mg_descendants), collapse="; ")
  
  #get_paths(mg_extraneous, mg_ancestors_kids)
  
  
  output$em.ancestors[n] <- paste(em_ancestors, collapse="; ")
  output$mg.ancestors[n] <- paste(mg_ancestors, collapse="; ")
  output$em.descendants[n] <- paste(em_descendants, collapse="; ")
  output$mg.descendants[n] <- paste(mg_descendants, collapse="; ")

  term_df <- data.frame(
    typeOfTerm = rep(c("UniProtKB", "Descendants", "Ancestors", "Ancestors' kids", "Extraneous"), 2),
    NumTerms = c(length(em_buni), length(em_descendants), length(em_ancestors), length(em_ancestors_kids), length(em_extraneous),
             length(mg_buni), length(mg_descendants), length(mg_ancestors), length(mg_ancestors_kids), length(mg_extraneous)),
    Tool = rep(c("eggNOG Mapper", "metaGOmics"), each = 5) 
  )
  term_df$typeOfTerm <- factor(term_df$typeOfTerm, 
              levels = c("Extraneous", "Ancestors' kids", "Ancestors", "Descendants", "UniProtKB"))

  plot <- ggplot(term_df, aes(x = Tool, y = NumTerms, fill = typeOfTerm)) +
    geom_bar(color = "black", stat = "identity", position = "stack") +
    scale_fill_manual("Type of term", values = c("Extraneous" = "#D576EE",
                      "Ancestors' kids" = "#A4A233", "Ancestors" = "#E57D74",
                      "Descendants" = "#4FAFE4", "UniProtKB" = "#5DBA85")) +
    ggtitle(all_results[n, 'peptide']) +
    theme_update(plot.title = element_text(hjust = 0.5))
  print(plot)
  #print(get_go_names(buni_split))
  #print(get_go_names(em_extraneous))
  #print(paste(all_results[n, 'peptide'], get_go_names(all_results[n, 'ups_go'])))
 }
}
#pander::pander(output, split.cell = 10, split.table = Inf)
```

```{r}
get_stats <- function(data){
  result <- str_split(data, '; ', simplify=TRUE)
  nums <- as.numeric(result[result != 'NA'])
  c(mean(nums),
      sd(nums),
    length(nums))
}

row <- paths[16,]
row$Peptide
#result <- str_split(paths$mg.extraneous.to.ancestors.kids[1], '; ', simplify=TRUE)
get_stats(row$em.extraneous.to.ancestors.kids)

em_tabular_paths <- data.frame(UniProt.to.Ancestors = get_stats(row$em.uniprot.to.ancestors),
                            Extraneous.to.Ancestors.Kids = get_stats(row$em.extraneous.to.ancestors.kids),
                            Extraneous.to.Ancestors = get_stats(row$em.extraneous.to.ancestors),
                            UniProt.to.Descendants = get_stats(row$em.uniprot.to.descendants))
row.names(em_tabular_paths) = c("mean", "sd", "number")

mg_tabular_paths <- data.frame(UniProt.to.Ancestors = get_stats(row$mg.uniprot.to.ancestors),
                            Extraneous.to.Ancestors.Kids = get_stats(row$mg.extraneous.to.ancestors.kids),
                            Extraneous.to.Ancestors = get_stats(row$mg.extraneous.to.ancestors),
                            UniProt.to.Descendants = get_stats(row$mg.uniprot.to.descendants))
row.names(mg_tabular_paths) = c("mean", "sd", "number")
```
```{r}
#paste(map_paths(mg_buni, mg_descendants), collapse="; ")
#mg_buni[17]
#mg_descendants[1]
#shortest_path(mg_buni[34], mg_descendants[1])
#here <- str_split(paths$mg.uniprot.to.descendants, '; ', simplify=TRUE)
```

```{r}
### Get distance -->
get_paths <- function(from, to){
     base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
     from_clean <- str_replace(from, ":", "%3A")
     to_clean <- str_replace(to, ":", "%3A")
     term_url <- paste(base_url, from_clean,
                       "/paths/", to_clean, "?relations=is_a", sep="")
     paths <- GET(term_url, accept("application/json"))
     json <- toJSON(content(paths))
     names <- fromJSON(json)$results
     names
}

shortest_path <- function(go1, go2){
  if (go1 == go2){
    'NA'
  } else{
     paths1_2 <- get_paths(go1, go2)
     paths2_1 <- get_paths(go2, go1)
     paths <- c(paths1_2, paths2_1)
     if (length(paths1_2) + length(paths2_1) == 0){
       'NA'
     } else {
       min(sapply(paths, nrow))
     }
  }
}

map_paths <- function(ref_terms, targ_terms){
  # Creates "heat map" of available pathing between terms
  results <- sapply(targ_terms, function(targ_term) 
                  sapply(ref_terms, function(ref_term) 
                         shortest_path(ref_term, targ_term)))
  return(results)
  # Removes NA results and converts to digits
  return(as.numeric(results[results != "NA"]))
}
```


```{r}
row <- output[output$Peptide == "EEVAEEAQSGGD",]
#uniprot <- str_split(row$Uniprot, '; ', simplify = TRUE)
# length(intersect(str_split(row$BLAST, '; ', simplify = TRUE),
#           str_split(row$Uniprot, '; ', simplify = TRUE))) / length(uniprot)
# length(intersect(str_split(row$Unipept, '; ', simplify = TRUE),
#           str_split(row$Uniprot, '; ', simplify = TRUE))) / length(uniprot)

uniprot_terms <- str_split(row$Uniprot, '; ', simplify = TRUE)
em_extra_terms <- str_split(row$em.extraneous, '; ', simplify = TRUE)
em_terms <- str_split(row$em.list, '; ', simplify = TRUE)
buni_terms <- str_split(row$BLAST, '; ', simplify = TRUE)
em_ancestors_terms <- str_split(row$em.ancestors, '; ', simplify = TRUE)

uniprot_notBLAST <- setdiff(unlist(uniprot_terms), buni_terms) # Terms not covered by BLAST
get_go_names(uniprot_terms)
get_go_names(uniprot_notBLAST)
get_go_names(em_extra_terms)
get_go_names(buni_split)

#   length(uniprot_notBLAST)
# uniprot_notBLAST_isExtra <- intersect(em_extra_terms,uniprot_notBLAST) # Terms not covered by BLAST but covered by extraneousEggNOG
#   length(uniprot_notBLAST_isExtra)
# uniprot_notBLAST_notExtra <- setdiff(unlist(uniprot_notBLAST), em_extra_terms)
#   length(uniprot_notBLAST_notExtra)
# intersect(em_ancestors_terms, uniprot_notBLAST_notExtra)

# intersect(uniprot_terms, buni_terms)
# length(intersect(uniprot_terms, buni_terms))/length(uniprot_terms)
# length(intersect(uniprot_terms, em_terms))/length(uniprot_terms)
# get_go_names(intersect(uniprot_terms, em_terms))
# get_go_names(em_terms)
# length(em_terms)
#intersect(uniprot_terms, em_terms)
#intersect(em_terms, buni_terms)
```
```{r}
# TO-DO: Support larger queries
#length(ancestors)
get_children <- function(goids){
    base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/'
    terms <- str_replace(goids, ":", "%3A")
    joined_terms <- paste(terms, collapse="%2C")
    term_url <- paste(base_url, joined_terms, sep="")
    term_info <- GET(term_url, accept("application/json"))
    json <- toJSON(content(term_info))
    children <- fromJSON(json)$results$children
    children_is_a <- lapply(children, function(x) unlist(x[x$relation == "is_a", ]$id))
    return(children_is_a)
}
# 16th peptide
#get_children(ancestors[1:520]) Works
#get_children(ancestors[1:530]) Doesn't work
```



```{r}
# Check if there is no overlap between categories
n <- 1
length(str_split(output$em.buni[n],'; ', simplify=TRUE)) + length(str_split(output$em.descendants[n],'; ', simplify=TRUE)) +
length(str_split(output$em.ancestors[n],'; ', simplify=TRUE)) + length(str_split(output$em.ancestors.kids[n],'; ', simplify=TRUE)) +
length(str_split(output$em.extraneous[n],'; ', simplify=TRUE))
intersect(str_split(output$em.descendants[n],'; ', simplify=TRUE),
          str_split(output$em.ancestors.kids[n],'; ', simplify=TRUE))
intersect(str_split(output$em.descendants[n],'; ', simplify=TRUE),
          str_split(output$em.ancestors[n],'; ', simplify=TRUE))
get_go_names("GO:0051403") #stress-activated MAPK cascade = descendant and ancestors kid
str_split(output$em.buni[n],'; ', simplify=TRUE)
get_go_names(str_split(output$em.buni[n],'; ', simplify=TRUE))
get_go_names("GO:0005768") #endosome" = Descendants and ancestor
get_go_names("GO:0000165") # MAPK cascade Descendants and ancestor
get_go_names(str_split(output$em.descendants[n],'; ', simplify=TRUE))
#get_go_names(str_split(output$em.extraneous[n],'; ', simplify=TRUE))
#get_go_names(str_split(output$em.ancestors.kids[n],'; ', simplify=TRUE))
#== length(eggnog_list)
length(str_split(output$em.list[n], '; ', simplify=TRUE))
```

```{r}
terms <- str_split(output$em.ancestors[1], "; ", simplify = TRUE)
print(terms)
print(get_go_names(terms))
```


```{r}
#shortest_path("GO:0014059","GO:0008344")
#get_go_names(c("GO:0014059","GO:0046928"))
# Behavior: GO:0007610
# Locomotory behavior: GO:0007626
# Adult behavior: GO:0030534
# Adult locomotory behavior: GO:0008344
#shortest_path("GO:0008344", "GO:0030534")
#shortest_path("GO:0007626","GO:0030534")
#term <- "GO:0043005"
#get_go_names(term)
#get_go_names(get_go_ancestors(term))
```


<!-- Calculate proportions to answer three questions: -->
<!-- 1) How many of Uniprot's terms does the tool pick up? -->
<!-- 2) What is the proportion of total terms from the tool that are extraneous? -->

<!-- #### Eggnog -->
<!-- ```{r} -->
<!-- # answer to 1 -->
<!-- length(intersect(eggnog_list, buni_split)) / length(buni_split) -->

<!-- # answer to 2 -->
<!-- length(em_diff_with_kids)/length(eggnog_list) -->
<!-- ``` -->

<!-- #### MetaGOmics -->
<!-- ```{r} -->
<!-- # answer to 1 -->
<!-- length(intersect(metaGOmics_list, buni_split)) / length(buni_split) -->

<!-- # answer to 2 -->
<!-- length(mg_diff_with_kids)/length(metaGOmics_list) -->
<!-- ``` -->


<!-- metaGOmics -->
<!-- ```{r} -->
<!-- diff <- setdiff(metaGOmics_list, full_tree) -->
<!-- get_go_names(diff) -->
<!-- ``` -->

<!-- eggNOG mapper -->
<!-- ```{r} -->
<!-- em_diff <- setdiff(eggnog_list, full_tree) -->
<!-- get_go_names(em_diff) -->
<!-- ``` -->

<!-- Visualize the overlap between the full Blast+Unipept tree (descendants, ancestors) and the eggNOG and metaGOmics term lists. -->
<!-- ```{r fig.width=4, fig.height=4} -->
<!-- library(VennDiagram) -->
<!-- grid.newpage() -->
<!-- grid.draw(venn.diagram( -->
<!--     list("eggnog" = eggnog_list, "blast+unipept" = full_tree, "metagomics" = metaGOmics_list), -->
<!--     NULL)) -->
<!-- file.remove(list.files(pattern = "VennDiagram.*log")) # venn diagram log files -->
<!-- ``` -->

<!-- ## Future directions -->
<!-- 1) repeat this for the other 4 peptides -->
<!-- 2) how do we handle terms that are not descendants or ancestors? We could define some distance cutoff, and say that everything beyond that is a false hit. For example, we could say that if the shortest path between a metaGOmics or eggNOG term and any term in the full B+U tree has length greater than or equal to 2 than it is a false hit. -->

<!-- ### Get distance -->
<!-- ```{r} -->
<!-- get_paths <- function(from, to){ -->
<!--     base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/' -->
<!--     from_clean <- str_replace(from, ":", "%3A") -->
<!--     to_clean <- str_replace(to, ":", "%3A") -->
<!--     term_url <- paste(base_url, from_clean, -->
<!--                       "/paths/", to_clean, "?relations=is_a", sep="") -->
<!--     paths <- GET(term_url, accept("application/json")) -->
<!--     json <- toJSON(content(paths)) -->
<!--     names <- fromJSON(json)$results -->
<!--     names -->
<!-- } -->

<!-- shortest_path <- function(go1, go2){ -->
<!--     paths1_2 <- get_paths(go1, go2) -->
<!--     paths2_1 <- get_paths(go2, go1) -->
<!--     paths <- c(paths1_2, paths2_1) -->
<!--     min(sapply(paths, length)) -->
<!-- } -->

<!-- shortest_path("GO:1901136", "GO:0008150") -->
<!-- ``` -->

<!-- ## GO glossary -->

<!-- Here, I get the names of all the above GO terms. -->

<!-- ``` -->
<!-- library(httr) -->
<!-- library(jsonlite) -->
<!-- base_url <- 'https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/' -->
<!-- term_url <- paste(base_url, 'GO%3A0008150%2CGO%3A0008152', sep="") -->
<!-- term_info <- GET(term_url, verbose(), accept("application/json")) -->
<!-- json <- toJSON(content(term_info)) -->
<!-- df <- fromJSON(json)$results -->
<!-- ``` -->